2022.03.17 TIL

### Live Session
- [SOLID]
- [Interface]

### SOLID: 객체 지향 프로그래밍 및 설계의 5가지 기본 원칙
목표
- 유지보수와 확장이 쉽게
- 재사용성
- 코드 가독성
- 코드 품질. 소프트웨어의 가치을 높이기 위해서
- 가치: 가독성, 커뮤니케이션의 용이성, 단순성, 유연성. 원칙은 가치를 지키기 위해 존재한다.
    - 가치를 매기는 기준: 얼마나 최소한의 비용으로 최대의 효과를 얻을 수 있는가?

1. SRP (Single Responsibility Principle)
- 단일 책임 원칙. 한 클래스는 하나의 __책임__ 만 가져야 한다.
- 하나의 기능만 한다는 뜻이 아님.
- 책임이란? 쉽게 말해 하나의 모듈을 변경할 이유가 오직 하나여야 한다는 것
- 응집도를 높이는 방법

2. OCP(Open-Closed Principle)
- 개방-폐쇄 원칙. 소프트웨어 요소는 "확장에는 열려 있으나 변경에는 닫혀 있어야 한다." <-- 헷갈리는 용어에 주의
- A 모듈의 변경으로부터 B 모듈을 보호하는 방법: A가 B에 의존하게 한다.(B가 A에 의존하지 않게!)
- DIP와 연관
- 새 기능이나 새 타입을 추가할 때 연쇄적으로 많은 변경이 필요해지면 이 원칙에 위반된 것

3. LSP(Liskov Substitution Principle)
- 리스코프 치환 원칙. 부모 클래스의 자리에 자식 클래스를 그대로 치환해도 문제없이 돌아가야 한다.
- 즉 서브 타입은 기본 타입으로 대체 가능해야 한다.
- 자식 클래스는 부모 클래스의 동작의 __의미__ 를 변경하지 않아야 한다.
- 이 원칙을 지키지 않으면 클래스의 타입을 이용하는 코드마다 실제 타입이 무엇인지(부모 클래스인지 자식 클래스인지) 확인하는 절차가 필요해진다. 클래스에 따라 동작의 의미가 달라졌으므로!

4. ISP(Interface Segregation Principle)
- 인터페이스 분리 원칙. 인터페이스를 작게 유지하라. Fat Interface를 만들지 말아라
- 무작정 작게 유지해야 한다는 의미가 아니라 실제로 필요로 하는 것 이외에는 포함하지 않도록 (작은 모듈 상태로) 유지하는 것이 좋다.
- 프로토콜이 요구하는 내용을 모두 구현해야 하는데, 그 중 불필요한 것이 있을 수 있기 때문에 때로는 상속받은 메소드를 퇴화시켜야 하는 경우가 발생할 수 있음
이럴 때 이걸 깨서 작은 인터페이스로 분리하는 것이 낫다.
- 야구게임 점수 계산기는 야구게임에서의 기능만, 축구게임 점수 계산기는 축구게임에서의 기능만 담는다. 둘 다 '운동경기 점수 계산기'니까 통합한 모듈을 만든다면 신규 기능 추가 시 오류 발생의 위험도가 높아진다.

5. DIP(Dependency Inversion Principle)
- 의존성 역전 원칙. 상위 클래스가 하위 클래스에 의존하지 않게 한다.
- 구체적인 타입에 대한 의존도를 낮추고, 추상 타입에 의존도를 높인다.
- 쉽게 말하면, 구체적인 클래스나 구조체에 의존도를 낮추고, 프로토콜과 같은 추상 타입에 의존하도록 코드를 작성한다.

인터페이스: 프로그램 내부 전체에서 어딘가의 접합부?? 프로그램 내부 구성요소들 사이의 상호작용하는 매개체
통신을 하기 위한 서로 간의 약속


### 연결 리스트에서의 메모리 해제
- 연결 리스트 구현 중 리스트의 element들을 전부 지우고 초기화할 때 다음과 같이 사용했다. 그런데 의존모둠과 함께 리뷰를 하던 도중 head와 tail에 해당하는 노드들만 제거했을 뿐, 그 사이 노드들은 서로 참조하고 있기 때문에 어떻게 메모리에서 해제가 됐다고 확신할 수 있을까 궁금증이 생겨 리뷰어에게 질문을 드렸다.
```swift
public func removeAll() {
    count = 0
    head = nil
    tail = nil
}
```

<C의 경우>

메모리에 데이터와 참조 여부가 존재. 
head와 tail이 사라지면 중간 노드에 접근할 수 있는 방법이 없어지기 때문에 데이터는 남아있어도 참조 여부가 X가 된다
물리적으로 메모리 공간이 지워지진 않지만 사용 가능한 공간으로 인식하고 덮어 씌워짐

<Swift의 경우>
- ARC 메모리 관리 모델을 사용
- 소유 정책(Ownership)과 참조 카운트(Reference Count)
- 인스턴스는 하나 이상의 소유자가 있는 경우 메모리에 유지된다. 반대로 소유자가 없는 경우 메모리에서 제거된다.
- 메모리 제거 시점을 파악하기 위해 소유자의 수를 별도로 체크한다.
head: nil
+------------+       +------------+     +------------+       +------------+
|node 0      |       |node 1      |     |node 2      |       |node 3      |     
|data 0      |       |data 1      |     |data 2      |       |data 3      |
|prev: nil   |       |prev: node 0|     |prev: node 1|       |prev: node 2|
|next: node 1|------>|next: node 2|-----|next: node 3|------>|next: nil   |
+------------+       +------------+     +------------+       +------------+


       +------------+     +------------+       
       |node 1      |     |node 2      |           
       |data 1      |     |data 2      |       
       |prev: node 0|     |prev: node 1|       
       |next: node 2|-----|next: node 3|
       +------------+     +------------+       
소유자가 없어서 node 1 제거됨
--> 소유자가 없어서 node 2 제거됨
--> ... 차례대로 소유자가 사라진 노드가 제거됨

* 양방향 연결 리스트의 경우 head와 tail의 노드를 모두 없애주어야 하고 단방향 연결 리스트의 경우 head의 노드만 nil로 변경하면 된다.
